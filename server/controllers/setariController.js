const User = require('../models/User');
const bcrypt = require('bcryptjs');
const Joi = require('joi');

// Schema validare pentru creare utilizator
const createUserSchema = Joi.object({
  nume: Joi.string().trim().max(100).required().messages({
    'string.empty': 'Numele este obligatoriu',
    'string.max': 'Numele nu poate depƒÉ»ôi 100 caractere'
  }),
  email: Joi.string().email().required().messages({
    'string.email': 'Email invalid',
    'string.empty': 'Email-ul este obligatoriu'
  }),
  parola: Joi.string().min(6).required().messages({
    'string.min': 'Parola trebuie sƒÉ aibƒÉ minim 6 caractere',
    'string.empty': 'Parola este obligatorie'
  }),
  confirmaParola: Joi.string().valid(Joi.ref('parola')).required().messages({
    'any.only': 'Confirmarea parolei nu coincide cu parola',
    'any.required': 'Confirmarea parolei este obligatorie'
  }),
  rol: Joi.string().valid('admin', 'user').default('user').required().messages({
    'any.only': 'Rolul trebuie sƒÉ fie admin sau user',
    'any.required': 'Rolul este obligatoriu'
  })
});

// Schema validare pentru actualizare utilizator
const updateUserSchema = Joi.object({
  nume: Joi.string().trim().max(100).optional(),
  email: Joi.string().email().optional(),
  rol: Joi.string().valid('admin', 'user').optional(),
  activ: Joi.boolean().optional()
});

// Ob»õine to»õi utilizatorii
const getUsers = async (req, res) => {
  try {
    // Doar adminii pot vedea to»õi utilizatorii
    if (req.user.rol !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acces interzis - necesitƒÉ drepturi de administrator'
      });
    }

    const users = await User.find({})
      .select('-parola')
      .sort({ dataCreare: -1 });

    res.json({
      success: true,
      data: users
    });

  } catch (error) {
    console.error('Eroare la ob»õinerea utilizatorilor:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la ob»õinerea utilizatorilor',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// CreeazƒÉ utilizator nou
const createUser = async (req, res) => {
  try {
    console.log('üîÑ [CREATE USER] √éncepe crearea utilizatorului...');
    console.log('üë§ [CREATE USER] Utilizator curent:', req.user?.nume, 'cu rolul:', req.user?.rol);
    console.log('üì® [CREATE USER] Payload primit:', req.body);

    // Doar adminii pot crea utilizatori
    if (req.user.rol !== 'admin') {
      console.log('‚ùå [CREATE USER] Acces interzis - nu este admin');
      return res.status(403).json({
        success: false,
        message: 'Acces interzis - necesitƒÉ drepturi de administrator'
      });
    }

    // Validare date
    const { error, value } = createUserSchema.validate(req.body);
    if (error) {
      console.log('‚ùå [CREATE USER] Eroare validare Joi:', error.details.map(d => d.message));
      return res.status(400).json({
        success: false,
        message: 'Date invalide',
        errors: error.details.map(detail => detail.message)
      });
    }

    console.log('‚úÖ [CREATE USER] Validare Joi trecutƒÉ cu succes:', value);

    const { nume, email, parola, rol } = value;

    // VerificƒÉ dacƒÉ email-ul existƒÉ deja
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Un utilizator cu acest email existƒÉ deja'
      });
    }

    // CreeazƒÉ utilizatorul nou
    const user = new User({
      nume,
      email,
      parola,
      rol
    });

    await user.save();

    // ReturneazƒÉ utilizatorul fƒÉrƒÉ parola
    const userResponse = await User.findById(user._id).select('-parola');

    res.status(201).json({
      success: true,
      message: 'Utilizator creat cu succes',
      data: userResponse
    });

  } catch (error) {
    console.error('Eroare la crearea utilizatorului:', error);

    if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({
        success: false,
        message: 'Eroare la validarea datelor',
        errors
      });
    }

    res.status(500).json({
      success: false,
      message: 'Eroare la crearea utilizatorului',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// ActualizeazƒÉ utilizator
const updateUser = async (req, res) => {
  try {
    // Doar adminii pot actualiza utilizatori
    if (req.user.rol !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acces interzis - necesitƒÉ drepturi de administrator'
      });
    }

    const { id } = req.params;

    // Validare date
    const { error, value } = updateUserSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: 'Date invalide',
        errors: error.details.map(detail => detail.message)
      });
    }

    // Nu permite actualizarea propriului cont (pentru siguran»õƒÉ)
    if (id === req.user.id) {
      return res.status(400).json({
        success: false,
        message: 'Nu pute»õi modifica propriul cont'
      });
    }

    // DacƒÉ se actualizeazƒÉ email-ul, verificƒÉ unicitatea
    if (value.email) {
      const existingUser = await User.findOne({ email: value.email, _id: { $ne: id } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'Un utilizator cu acest email existƒÉ deja'
        });
      }
    }

    const user = await User.findByIdAndUpdate(
      id,
      value,
      { new: true, runValidators: true }
    ).select('-parola');

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Utilizator negƒÉsit'
      });
    }

    res.json({
      success: true,
      message: 'Utilizator actualizat cu succes',
      data: user
    });

  } catch (error) {
    console.error('Eroare la actualizarea utilizatorului:', error);

    if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({
        success: false,
        message: 'Eroare la validarea datelor',
        errors
      });
    }

    res.status(500).json({
      success: false,
      message: 'Eroare la actualizarea utilizatorului',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// »òterge utilizator
const deleteUser = async (req, res) => {
  try {
    // Doar adminii pot »ôterge utilizatori
    if (req.user.rol !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acces interzis - necesitƒÉ drepturi de administrator'
      });
    }

    const { id } = req.params;

    // Nu permite »ôtergerea propriului cont
    if (id === req.user.id) {
      return res.status(400).json({
        success: false,
        message: 'Nu pute»õi »ôterge propriul cont'
      });
    }

    const user = await User.findByIdAndDelete(id);

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Utilizator negƒÉsit'
      });
    }

    res.json({
      success: true,
      message: 'Utilizator »ôters cu succes'
    });

  } catch (error) {
    console.error('Eroare la »ôtergerea utilizatorului:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la »ôtergerea utilizatorului',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// SchimbƒÉ parola utilizatorului curent
const changePassword = async (req, res) => {
  try {
    const { parolaActuala, parolaNoua, confirmaParola } = req.body;

    // Validare parole
    if (!parolaActuala || !parolaNoua || !confirmaParola) {
      return res.status(400).json({
        success: false,
        message: 'Toate c√¢mpurile sunt obligatorii'
      });
    }

    if (parolaNoua !== confirmaParola) {
      return res.status(400).json({
        success: false,
        message: 'Confirmarea parolei nu coincide'
      });
    }

    if (parolaNoua.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'Parola nouƒÉ trebuie sƒÉ aibƒÉ minim 6 caractere'
      });
    }

    // GƒÉse»ôte utilizatorul »ôi verificƒÉ parola actualƒÉ
    const user = await User.findById(req.user.id).select('+parola');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Utilizator negƒÉsit'
      });
    }

    const isValidPassword = await user.verificaParola(parolaActuala);
    if (!isValidPassword) {
      return res.status(400).json({
        success: false,
        message: 'Parola actualƒÉ este incorectƒÉ'
      });
    }

    // ActualizeazƒÉ parola
    user.parola = parolaNoua;
    await user.save();

    res.json({
      success: true,
      message: 'Parola schimbatƒÉ cu succes'
    });

  } catch (error) {
    console.error('Eroare la schimbarea parolei:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la schimbarea parolei',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// Ob»õine setƒÉrile aplica»õiei (momentan doar informa»õii de bazƒÉ)
const getAppSettings = async (req, res) => {
  try {
    const settings = {
      appName: 'Transio',
      version: '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      features: {
        rapoarte: true,
        export: true,
        multiUser: true,
        notifications: false // Pentru viitor
      }
    };

    res.json({
      success: true,
      data: settings
    });

  } catch (error) {
    console.error('Eroare la ob»õinerea setƒÉrilor:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la ob»õinerea setƒÉrilor',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// Schema pentru validare setƒÉri facturi - permite string-uri numerice
const setariFacturiSchema = Joi.object({
  serie: Joi.string().trim().max(5).required().messages({
    'string.empty': 'Seria este obligatorie',
    'string.max': 'Seria nu poate depƒÉ»ôi 5 caractere'
  }),
  numarCurent: Joi.alternatives().try(
    Joi.number().integer().min(1).max(999999),
    Joi.string().pattern(/^\d+$/).custom((value, helpers) => {
      const numValue = parseInt(value, 10);
      if (numValue < 1) {
        return helpers.error('number.min');
      }
      if (numValue > 999999) {
        return helpers.error('number.max');
      }
      return numValue;
    })
  ).required().messages({
    'number.base': 'NumƒÉrul curent trebuie sƒÉ fie un numƒÉr',
    'number.min': 'NumƒÉrul curent trebuie sƒÉ fie minim 1',
    'number.max': 'NumƒÉrul curent nu poate fi mai mare de 999999',
    'string.pattern.base': 'NumƒÉrul curent trebuie sƒÉ con»õinƒÉ doar cifre',
    'any.required': 'NumƒÉrul curent este obligatoriu'
  })
});

// Schema pentru validare setƒÉri firmƒÉ
const setariFirmaSchema = Joi.object({
  numeFirma: Joi.string().trim().max(200).required().messages({
    'string.empty': 'Numele firmei este obligatoriu',
    'string.max': 'Numele firmei nu poate depƒÉ»ôi 200 caractere'
  }),
  cui: Joi.string().trim().max(50).required().messages({
    'string.empty': 'CUI este obligatoriu',
    'string.max': 'CUI nu poate depƒÉ»ôi 50 caractere'
  }),
  adresaCompleta: Joi.string().trim().max(500).optional().allow(''),
  telefon: Joi.string().trim().max(20).optional().allow(''),
  email: Joi.string().email().optional().allow(''),
  bancaNumeComplet: Joi.string().trim().max(200).optional().allow(''),
  iban: Joi.string().trim().max(50).optional().allow(''),
  reprezentantLegal: Joi.string().trim().max(200).optional().allow('')
});

// Import modelul Setari
const Setari = require('../models/Setari');

// Cache √Æn memorie pentru performan»õƒÉ
let setariFacturiCache = null;
let setariFirmaCache = null;

// Ob»õine setƒÉri facturi
const getSetariFacturi = async (req, res) => {
  try {
    let setariFacturi = setariFacturiCache;

    if (!setariFacturi) {
      // √éncarcƒÉ din baza de date folosind modelul Setari
      setariFacturi = await Setari.getSetari('facturi');

      if (!setariFacturi) {
        // SetƒÉri implicite
        setariFacturi = {
          serie: 'TR',
          numarCurent: 2
        };

        // SalveazƒÉ setƒÉrile implicite √Æn baza de date
        await Setari.saveSetari('facturi', setariFacturi);
      }

      setariFacturiCache = setariFacturi;
    }

    res.json({
      success: true,
      data: setariFacturi
    });

  } catch (error) {
    console.error('Eroare la ob»õinerea setƒÉrilor facturi:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la ob»õinerea setƒÉrilor facturi',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// SalveazƒÉ setƒÉri facturi
const saveSetariFacturi = async (req, res) => {
  try {
    // Doar adminii pot salva setƒÉri
    if (req.user.rol !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acces interzis - necesitƒÉ drepturi de administrator'
      });
    }

    console.log('üîç Payload primit pentru setƒÉri facturi:', JSON.stringify(req.body, null, 2));

    // Validare date
    const { error, value } = setariFacturiSchema.validate(req.body);
    if (error) {
      console.log('‚ùå Eroare validare setƒÉri facturi:', error.details);
      console.log('üìù Detalii eroare:', error.details.map(d => `${d.path.join('.')}: ${d.message}`));
      return res.status(400).json({
        success: false,
        message: 'Date invalide',
        errors: error.details.map(detail => detail.message)
      });
    }

    // AsigurƒÉ-te cƒÉ numarCurent este √Æntotdeauna un numƒÉr
    const setariProcesate = {
      ...value,
      numarCurent: typeof value.numarCurent === 'string' 
        ? parseInt(value.numarCurent, 10) 
        : value.numarCurent
    };

    console.log('‚úÖ SetƒÉri facturi validate »ôi procesate:', setariProcesate);

    // SalveazƒÉ √Æn baza de date folosind modelul Setari
    const setariSalvate = await Setari.saveSetari('facturi', setariProcesate);

    // ActualizeazƒÉ cache-ul
    setariFacturiCache = setariSalvate;

    res.json({
      success: true,
      message: 'SetƒÉri facturi salvate cu succes',
      data: setariSalvate
    });

  } catch (error) {
    console.error('Eroare la salvarea setƒÉrilor facturi:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la salvarea setƒÉrilor facturi',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// Ob»õine setƒÉri firmƒÉ
const getSetariFirma = async (req, res) => {
  try {
    let setariFirma = setariFirmaCache;
    
    if (!setariFirma) {
      // √éncearcƒÉ sƒÉ √ÆncƒÉrce din baza de date
      const setariDB = await Setari.findOne({ tip: 'firma' });
      
      if (setariDB) {
        setariFirma = setariDB.data;
        setariFirmaCache = setariFirma;
      } else {
        // SetƒÉri implicite goale
        setariFirma = {
          numeFirma: '',
          cui: '',
          adresaCompleta: '',
          telefon: '',
          email: '',
          bancaNumeComplet: '',
          iban: '',
          reprezentantLegal: ''
        };
        setariFirmaCache = setariFirma;
      }
    }

    res.json({
      success: true,
      data: setariFirma
    });

  } catch (error) {
    console.error('Eroare la ob»õinerea setƒÉrilor firmƒÉ:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la ob»õinerea setƒÉrilor firmƒÉ',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// SalveazƒÉ setƒÉri firmƒÉ
const saveSetariFirma = async (req, res) => {
  try {
    // Doar adminii pot salva setƒÉri
    if (req.user.rol !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acces interzis - necesitƒÉ drepturi de administrator'
      });
    }

    // Validare date
    const { error, value } = setariFirmaSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: 'Date invalide',
        errors: error.details.map(detail => detail.message)
      });
    }

    // SalveazƒÉ √Æn baza de date
    await Setari.findOneAndUpdate(
      { tip: 'firma' },
      { data: value },
      { upsert: true, new: true }
    );

    // ActualizeazƒÉ cache-ul
    setariFirmaCache = value;

    res.json({
      success: true,
      message: 'SetƒÉri firmƒÉ salvate cu succes',
      data: value
    });

  } catch (error) {
    console.error('Eroare la salvarea setƒÉrilor firmƒÉ:', error);
    res.status(500).json({
      success: false,
      message: 'Eroare la salvarea setƒÉrilor firmƒÉ',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// Func»õii helper interne pentru accesul din alte module (ex: Factura model)
const getSetariFacturiInternal = async () => {
  try {
    let setariFacturi = setariFacturiCache;

    if (!setariFacturi) {
      // √éncarcƒÉ din baza de date folosind modelul Setari
      setariFacturi = await Setari.getSetari('facturi');

      if (!setariFacturi) {
        // SetƒÉri implicite
        setariFacturi = {
          serie: 'TR',
          numarCurent: 2
        };

        // SalveazƒÉ setƒÉrile implicite √Æn baza de date
        await Setari.saveSetari('facturi', setariFacturi);
      }

      setariFacturiCache = setariFacturi;
    }

    return setariFacturi;
  } catch (error) {
    console.error('Eroare la ob»õinerea setƒÉrilor facturi (internal):', error);
    // ReturneazƒÉ setƒÉrile implicite √Æn caz de eroare
    return {
      serie: 'TR',
      numarCurent: 1
    };
  }
};

const saveSetariFacturiInternal = async (noileSetari) => {
  try {
    // SalveazƒÉ √Æn baza de date folosind modelul Setari
    const setariSalvate = await Setari.saveSetari('facturi', noileSetari);

    // ActualizeazƒÉ cache-ul
    setariFacturiCache = setariSalvate;

    return setariSalvate;
  } catch (error) {
    console.error('Eroare la salvarea setƒÉrilor facturi (internal):', error);
    throw error;
  }
};

module.exports = {
  getUsers,
  createUser,
  updateUser,
  deleteUser,
  changePassword,
  getAppSettings,
  getSetariFacturi,
  saveSetariFacturi,
  getSetariFirma,
  saveSetariFirma,
  // Func»õii helper interne
  getSetariFacturiInternal,
  saveSetariFacturiInternal
};
